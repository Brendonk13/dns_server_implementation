import socket
from header_helpers import *
from zone_helpers import *
from data.prog_data import ENDIAN, QUERY_TYPES

# DNS SPECIFICATION: https://www.ietf.org/rfc/rfc1035.txt



class DnsQuestion:

    def __init__(self, domain_parts, query_type):
        query_name = self.query_name(domain_parts)
        query_type = self.query_type(query_type)
        query_class = self.query_class()

        self.question = query_name + query_type + query_class

    def query_name(self, domain_parts):
        """
        query name format:
        length of domain part, domain part, length of domain part, domain part, repeat....
        \x00 to mark termination of domain name
        """

        query_name = b''
        for domain_part in domain_parts:
            # mark the length of the https://github.com/Brendonk13/dns_server_implementationpart
            query_name += bytes([len(domain_part)])
            # add the characters
            for char in domain_part:
                query_name += ord(char).to_bytes(1, byteorder=ENDIAN)

        # mark termination of the domain_name with \x00
        return query_name + (0).to_bytes(1, byteorder=ENDIAN)

    def query_type(self, query_type):
        return (QUERY_TYPES[query_type]).to_bytes(2, byteorder=ENDIAN)

    def query_class(self):
        """
        2 bytes to mark the query class -- almost always "IN" -> Internet
        (always for this server)
        """
        return (1).to_bytes(2, byteorder=ENDIAN)

    def __add__(self, other):
        return self.question + other
    def __radd__(self, other):
        return other + self.question



class DnsHeader:
    """
    The entire purpose of these functions being in a class
    is to clearly show what a DNS header is composed of
    """

    def __init__(self, query):
        """
        parse the queries binary query data to extract certain headers and flags
        which make up the response header
        """
        self.query = query
        # concatenate the bytes
        self.header = reduce(add, self.header_components())
        print(f'answer header:\n{self.header}')
        # return self.header

    def header_components(self):
        # These are all the components (in order!) that make up a DNS header !
        return (
                self.transaction_id(),
                self.flags(),
                self.question_count(),
                self.answer_count(),
                self.name_server_count(),
                self.additional_records_count()
        )


    def transaction_id(self):
        """
        16 bit identifier that is generated by the client and copied in the server's reply
        """
        return self.query[:2]

    def flags(self):
        """we use flags in the query to generate the flags in the response"""
        return extract_flags(self.query[2:4])

    def question_count(self):
        """
        question_count: historically dns clients would ask multiple questions per query
        nowadays they almost always just ask 1 q
        the number 1  --  in 2 bytes
        """
        return b'\x00\x01'

    def answer_count(self):
        """
        answer_count: if there is more than 1 A record returned then says how many
        think response records go here also
        """
        # query[12:]  -->  starting at this index is the domain name of the query
        records, _, _ = queried_records(self.query[12:])
        return len(records).to_bytes(2, byteorder=ENDIAN)


    def name_server_count(self):
        """
        ns_count: number of name servers returned (think this is for recursive dns servers)
        we arent going to send any name servers so this will be zero
        """
        return (0).to_bytes(2, byteorder=ENDIAN)

    def additional_records_count(self):
        """
        ar_count: additional records countt the zone file??
        not sending these for simplicity
        """
        return (0).to_bytes(2, byteorder=ENDIAN)

    def __add__(self, other):
        return self.header + other
    def __radd__(self, other):
        return other + self.header



class DnsAnswer:
    def __init__(self, records, query_type, domain_parts):
        self.answer = b''
        for record in records:
            print(record)
            self.answer += self._record_data(domain_parts, query_type, record)

    def _record_data(self, domain_parts, query_type, record):
        # mark offset to domain_name as 12 bytes (compression)
        # think this is wrong -- a ns record should probably return "host" -- cant compress here???
        domain_name_pointer = b'\xc0\x0c'

        answer_type = int(QUERY_TYPES[query_type]).to_bytes(2, byteorder=ENDIAN)

        # class = IN as per usual (other classes not used often)
        answer_class = bytes([0, 1])

        # is record_ttl only for A records ?? what is the global $ttl purpose in zone file ???
        ttl = record["ttl"] if "ttl" in record else get_zone(domain_parts)["$ttl"]
        ttl_answer = int(ttl).to_bytes(4, byteorder=ENDIAN)

        record_data = domain_name_pointer + answer_type + answer_class + ttl_answer

        # Todo: figure out why my responses to other types of queries are invalid then implement here.
        if query_type == 'a':
            resource_data_len = bytes([0, 4])
            print('making A record answer')
            record_data += resource_data_len

            for part in record["value"].split('.'):
                record_data += bytes([int(part)])

        return record_data

    def __add__(self, other):
        return self.answer + other
    def __radd__(self, other):
        return other + self.answer




def response(query):
    dns_header = DnsHeader(query)

    # 12 since the header is 12 bytes and the record info is stored after the header !
    record_info = queried_records(query[12:])
    records, query_type, domain_parts = record_info


    dns_question = DnsQuestion(domain_parts, query_type)
    dns_answer = DnsAnswer(*record_info)

    # Note: if we implemented it, we'd concatenate sections: Authority, Additional
        # (according to section 4.1 in spec)
        # the authority section contains RRs that point toward an authoritative name server;
        # the additional records section contains RRs which relate to the query, but are not strictly answers for the question.
    return dns_header + dns_question + dns_answer



if __name__ == '__main__':
    ip, port = '127.0.0.1', 53

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind((ip, port))

    while 1:
        # dns specification says that udp should be used for packets sz <= 512 bytes (octets)
        query, addr = sock.recvfrom(512)
        print(f'full query:\n{query}')
        print()

        r = response(query)
        sock.sendto(r, addr)

